import crypto from 'crypto';

/**
 * Verify ECDSA Signature (Server-Side)
 * 
 * Purpose:
 * - Verify signatures generated by the client's Web Crypto API
 * - Uses Node.js 'crypto' module
 * 
 * @param {Object} jwk - The public key in JWK format
 * @param {string} data - The data that was signed (string)
 * @param {string} signatureBase64 - The signature in Base64 format
 * @returns {boolean} True if signature is valid
 */
export const verifySignature = (jwk, data, signatureBase64) => {
    try {
        // 1. Import the public key from JWK
        const publicKey = crypto.createPublicKey({
            key: jwk,
            format: 'jwk'
        });

        // 2. Decode signature from Base64
        const signature = Buffer.from(signatureBase64, 'base64');

        // 3. Verify using SHA-256
        const verify = crypto.createVerify('SHA256');
        verify.update(data);
        verify.end();

        return verify.verify(publicKey, signature);
    } catch (error) {
        console.error('Server-side signature verification failed:', error);
        return false;
    }
};

/**
 * Verify Object Signature
 * 
 * Purpose:
 * - Verify signature of a JSON object
 * - Must match the serialization used on the client (JSON.stringify)
 * 
 * @param {Object} jwk - Public key in JWK format
 * @param {Object} obj - The object to verify
 * @param {string} signatureBase64 - Base64 signature
 * @returns {boolean}
 */
export const verifyObjectSignature = (jwk, obj, signatureBase64) => {
    try {
        // Canonical serialization is hard, but for this project we assume
        // standard JSON.stringify behavior matches between client/server
        // for simple objects.
        const jsonString = JSON.stringify(obj);
        return verifySignature(jwk, jsonString, signatureBase64);
    } catch (error) {
        console.error('Object verification failed:', error);
        return false;
    }
};
