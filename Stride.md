# STRIDE Threat Model Analysis

This document provides a comprehensive threat model for the Secure End-to-End Encrypted Messaging System using the STRIDE methodology. It maps potential threats to specific architectural controls and implemented defenses.

## System Overview
- **Architecture**: Client-Server (Node.js/Express + React)
- **Security Model**: End-to-End Encryption (E2EE) with Zero-Knowledge Server
- **Key Protocol**: Signed ECDH (P-256) + AES-256-GCM

---

## 1. Spoofing (Identity Theft)
**Threat**: An attacker impersonates a legitimate user (e.g., "Dobby" pretending to be "Amitabh") to send fake messages or intercept keys.

| Specific Threat | Implemented Control | Mechanism / Code Reference |
| :--- | :--- | :--- |
| **User Impersonation during Login** | **Strong Authentication** | `bcrypt` password hashing (Salt rounds: 12) prevents rainbow table attacks. JWT tokens used for session management. |
| **Man-in-the-Middle (MITM) during Key Exchange** | **Signed ECDH** | Ephemeral public keys are **signed** with the user's long-term Identity Private Key (ECDSA P-256). The receiver verifies this signature against the sender's pre-registered Identity Public Key. <br> *Ref: `keyExchange.js` (Client), `cryptoUtils.js` (Server)* |
| **Message Origin Spoofing** | **Digital Signatures** | Every encrypted message payload includes a digital signature (ECDSA) generated by the sender. The server verifies this signature before accepting the message. <br> *Ref: `messageRoutes.js` (Server)* |

---

## 2. Tampering (Data Modification)
**Threat**: An attacker modifies messages, keys, or metadata in transit or at rest.

| Specific Threat | Implemented Control | Mechanism / Code Reference |
| :--- | :--- | :--- |
| **Modifying Encrypted Messages** | **Authenticated Encryption** | Use of **AES-256-GCM** (Galois/Counter Mode). GCM provides both confidentiality and integrity. Any modification to the ciphertext or IV causes decryption to fail (Auth Tag mismatch). <br> *Ref: `encryption.js` (Client)* |
| **Altering Public Keys on Server** | **Signature Verification** | The server cannot modify public keys without invalidating the signatures that rely on them. While the server *stores* keys, clients verify the *signatures* on ephemeral keys using the trusted Identity Key. |
| **Reordering Messages** | **Sequence Numbers** | Each message contains a strictly increasing `sequenceNumber`. The server tracks the `lastSequenceNumber` per conversation direction and rejects out-of-order or replayed messages. <br> *Ref: `ConversationState.js` (Server)* |

---

## 3. Repudiation (Denying Actions)
**Threat**: A user denies sending a message or performing an action.

| Specific Threat | Implemented Control | Mechanism / Code Reference |
| :--- | :--- | :--- |
| **"I didn't send that message"** | **Non-Repudiation via Signatures** | Messages are signed with the sender's private Identity Key. Only the holder of the private key could have created the valid signature. The server logs and verifies this signature. |
| **"I didn't perform that key exchange"** | **Audit Logging** | The `AuditLog` system records `KEY_EXCHANGE_INITIATE` events with timestamps and user IDs. <br> *Ref: `AuditLog.js`, `keyRoutes.js`* |

---

## 4. Information Disclosure (Data Leakage)
**Threat**: Unauthorized access to confidential message content or user data.

| Specific Threat | Implemented Control | Mechanism / Code Reference |
| :--- | :--- | :--- |
| **Server Reading Messages** | **End-to-End Encryption (E2EE)** | The server **never** sees plaintext. It only stores `ciphertext`, `iv`, and `nonce`. Decryption keys (Session Keys) exist *only* on the client devices (IndexedDB). |
| **Database Breach** | **Zero-Knowledge Architecture** | Even if the MongoDB database is dumped, the attacker only gets encrypted blobs. They cannot decrypt them without the client-side keys. Passwords are hashed with `bcrypt`. |
| **Metadata Leakage** | **Minimal Metadata** | The system only stores necessary metadata (Sender, Receiver, Timestamp). Message content is opaque. |

---

## 5. Denial of Service (DoS)
**Threat**: Disrupting system availability for legitimate users.

| Specific Threat | Implemented Control | Mechanism / Code Reference |
| :--- | :--- | :--- |
| **Replay Attacks (Flooding)** | **Replay Protection** | The server enforces **Nonce Uniqueness** (via `ReplayLog`) and **Timestamp Windows** (5-minute validity). Replayed packets are dropped immediately. <br> *Ref: `messageRoutes.js`* |
| **API Rate Limiting** | **Express Rate Limit** | `express-rate-limit` is configured to restrict the number of requests per IP address, preventing brute-force and flooding attacks. <br> *Ref: `server.js`* |
| **Resource Exhaustion** | **Payload Validation** | The server validates input sizes and types before processing, preventing large payload attacks. |

---

## 6. Elevation of Privilege
**Threat**: An unprivileged user gains administrative or other users' access rights.

| Specific Threat | Implemented Control | Mechanism / Code Reference |
| :--- | :--- | :--- |
| **Accessing Other Users' Messages** | **Authorization Middleware** | `authMiddleware.js` verifies JWT tokens for every protected route. `messageRoutes.js` explicitly checks `if (currentUserId !== userId1 && currentUserId !== userId2)` before returning conversation history. |
| **Overwriting Others' Keys** | **Ownership Checks** | `keyRoutes.js` enforces that `req.user.userId === userId` before allowing key uploads or deletions. |

---

## Summary of Defense Layers

1.  **Network Layer**: HTTPS (Assumed/Localhost), Rate Limiting.
2.  **Application Layer**: JWT Auth, Input Validation, Business Logic Checks (Ownership).
3.  **Cryptographic Layer**: E2EE (AES-GCM), Signatures (ECDSA), Key Exchange (ECDH).
4.  **Data Layer**: Encrypted Storage, Hashed Passwords, Audit Logs.
